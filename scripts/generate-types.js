import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const modelsPath = path.join(__dirname, '../backend/src/models');
const outputPath = path.join(__dirname, '../frontend/src/types/models.ts');

const sequelizeToTypeScript = {
  'DataTypes.STRING': 'string',
  'DataTypes.TEXT': 'string',
  'DataTypes.INTEGER': 'number',
  'DataTypes.FLOAT': 'number',
  'DataTypes.DECIMAL': 'number',
  'DataTypes.BOOLEAN': 'boolean',
  'DataTypes.DATE': 'Date',
  'DataTypes.UUID': 'string',
  'DataTypes.ENUM': 'string',
  'DataTypes.JSON': 'any',
  'DataTypes.JSONB': 'any'
};

const generateTypes = async () => {
  try {
    const modelFiles = fs.readdirSync(modelsPath)
      .filter(file => file.endsWith('.js') && !file.startsWith('index'));

    let output = [
      '// Generated Types from Backend Models',
      '// DO NOT EDIT DIRECTLY - Generated by scripts/generate-types.js',
      '',
      'export type UUID = string;',
      'export type Timestamp = Date;',
      ''
    ].join('\n');

    for (const file of modelFiles) {
      const modelName = path.basename(file, '.js');
      const modelContent = fs.readFileSync(path.join(modelsPath, file), 'utf-8');

      // Extract model definition
      const typeRegex = /DataTypes\.[A-Z]+(?:\([^)]*\))?/g;
      const fieldRegex = /(\w+):\s*{[^}]*type:\s*(DataTypes\.[A-Z]+(?:\([^)]*\))?)/g;
      const enumRegex = /type:\s*DataTypes\.ENUM\(['"]([^'"]+)['"](?:\s*,\s*['"]([^'"]+)['"])*\)/g;

      let enumTypes = [];
      let match;

      // Process enums
      while ((match = enumRegex.exec(modelContent))) {
        const enumName = `${modelName}Type`;
        const enumValues = match[0].match(/['"]([^'"]+)['"]/g)
          .map(v => v.replace(/['"]/g, ''));
        enumTypes.push(`export type ${enumName} = ${enumValues.map(v => `'${v}'`).join(' | ')};\n`);
      }

      let interfaceContent = [];

      // Process fields
      while ((match = fieldRegex.exec(modelContent))) {
        const [, fieldName, fieldType] = match;
        const baseType = fieldType.split('(')[0];
        const tsType = sequelizeToTypeScript[baseType] || 'any';
        
        if (fieldName !== 'id' && fieldName !== 'createdAt' && fieldName !== 'updatedAt') {
          interfaceContent.push(`  ${fieldName}: ${tsType};`);
        }
      }

      // Add common fields
      interfaceContent.unshift('  id: UUID;');
      interfaceContent.push('  createdAt: Timestamp;');
      interfaceContent.push('  updatedAt: Timestamp;');

      // Add enums first
      output += enumTypes.join('');

      // Add interface
      output += [
        `export interface ${modelName} {`,
        interfaceContent.join('\n'),
        '}\n\n'
      ].join('\n');
    }

    // Create types directory if it doesn't exist
    const typesDir = path.dirname(outputPath);
    if (!fs.existsSync(typesDir)) {
      fs.mkdirSync(typesDir, { recursive: true });
    }

    // Write the output file
    fs.writeFileSync(outputPath, output);
    console.log(`Types generated successfully at ${outputPath}`);

  } catch (error) {
    console.error('Error generating types:', error);
    process.exit(1);
  }
};

// Run if called directly
if (require.main === module) {
  generateTypes();
}

export default generateTypes;
